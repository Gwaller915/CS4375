user/umalloc.c:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/umalloc.c:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/umalloc.c:  if(bp + bp->s.size == p->s.ptr){
user/umalloc.c:    bp->s.size += p->s.ptr->s.size;
user/umalloc.c:    bp->s.ptr = p->s.ptr->s.ptr;
user/umalloc.c:    bp->s.ptr = p->s.ptr;
user/umalloc.c:  if(p + p->s.size == bp){
user/umalloc.c:    p->s.size += bp->s.size;
user/umalloc.c:    p->s.ptr = bp->s.ptr;
user/umalloc.c:    p->s.ptr = bp;
user/umalloc.c:  hp->s.size = nu;
user/umalloc.c:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/umalloc.c:    if(p->s.size >= nunits){
user/umalloc.c:      if(p->s.size == nunits)
user/umalloc.c:        prevp->s.ptr = p->s.ptr;
user/umalloc.c:        p->s.size -= nunits;
user/umalloc.c:        p += p->s.size;
user/umalloc.c:        p->s.size = nunits;
user/pstree.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/pstree.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pstree.asm:  if(bp + bp->s.size == p->s.ptr){
user/pstree.asm:    bp->s.size += p->s.ptr->s.size;
user/pstree.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/pstree.asm:    bp->s.ptr = p->s.ptr;
user/pstree.asm:  if(p + p->s.size == bp){
user/pstree.asm:    p->s.size += bp->s.size;
user/pstree.asm:    p->s.ptr = bp->s.ptr;
user/pstree.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pstree.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/pstree.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pstree.asm:  if(bp + bp->s.size == p->s.ptr){
user/pstree.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/pstree.asm:  if(p + p->s.size == bp){
user/pstree.asm:    p->s.ptr = bp->s.ptr;
user/pstree.asm:    p->s.ptr = bp;
user/pstree.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/pstree.asm:    if(p->s.size >= nunits){
user/pstree.asm:        p->s.size = nunits;
user/pstree.asm:    if(p->s.size >= nunits){
user/pstree.asm:      if(p->s.size == nunits)
user/pstree.asm:        p->s.size -= nunits;
user/pstree.asm:        p += p->s.size;
user/pstree.asm:        p->s.size = nunits;
user/pstree.asm:        prevp->s.ptr = p->s.ptr;
user/pstree.asm:  hp->s.size = nu;
user/pstree.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/pstree.asm:    if(p->s.size >= nunits){
user/memory-user.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/memory-user.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/memory-user.asm:  if(bp + bp->s.size == p->s.ptr){
user/memory-user.asm:    bp->s.size += p->s.ptr->s.size;
user/memory-user.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/memory-user.asm:    bp->s.ptr = p->s.ptr;
user/memory-user.asm:  if(p + p->s.size == bp){
user/memory-user.asm:    p->s.size += bp->s.size;
user/memory-user.asm:    p->s.ptr = bp->s.ptr;
user/memory-user.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/memory-user.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/memory-user.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/memory-user.asm:  if(bp + bp->s.size == p->s.ptr){
user/memory-user.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/memory-user.asm:  if(p + p->s.size == bp){
user/memory-user.asm:    p->s.ptr = bp->s.ptr;
user/memory-user.asm:    p->s.ptr = bp;
user/memory-user.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/memory-user.asm:    if(p->s.size >= nunits){
user/memory-user.asm:        p->s.size = nunits;
user/memory-user.asm:    if(p->s.size >= nunits){
user/memory-user.asm:      if(p->s.size == nunits)
user/memory-user.asm:        p->s.size -= nunits;
user/memory-user.asm:        p += p->s.size;
user/memory-user.asm:        p->s.size = nunits;
user/memory-user.asm:        prevp->s.ptr = p->s.ptr;
user/memory-user.asm:  hp->s.size = nu;
user/memory-user.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/memory-user.asm:    if(p->s.size >= nunits){
user/private.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/private.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/private.asm:  if(bp + bp->s.size == p->s.ptr){
user/private.asm:    bp->s.size += p->s.ptr->s.size;
user/private.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/private.asm:    bp->s.ptr = p->s.ptr;
user/private.asm:  if(p + p->s.size == bp){
user/private.asm:    p->s.size += bp->s.size;
user/private.asm:    p->s.ptr = bp->s.ptr;
user/private.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/private.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/private.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/private.asm:  if(bp + bp->s.size == p->s.ptr){
user/private.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/private.asm:  if(p + p->s.size == bp){
user/private.asm:    p->s.ptr = bp->s.ptr;
user/private.asm:    p->s.ptr = bp;
user/private.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/private.asm:    if(p->s.size >= nunits){
user/private.asm:        p->s.size = nunits;
user/private.asm:    if(p->s.size >= nunits){
user/private.asm:      if(p->s.size == nunits)
user/private.asm:        p->s.size -= nunits;
user/private.asm:        p += p->s.size;
user/private.asm:        p->s.size = nunits;
user/private.asm:        prevp->s.ptr = p->s.ptr;
user/private.asm:  hp->s.size = nu;
user/private.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/private.asm:    if(p->s.size >= nunits){
user/usertests.c:// does chdir() call iput(p->cwd) in a transaction?
user/usertests.c:// does exit() call iput(p->cwd) in a transaction?
user/usertests.c:// release" due to exit() releasing a different p->parent->lock than
user/usertests.c:    // would not adjust p->sz correctly in this case,
user/usertests.c:// does sbrk handle signed int32 wrap-around with
user/usertests.c:  *(top-1) = *(top-1) + 1;
user/zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/zombie.asm:  if(bp + bp->s.size == p->s.ptr){
user/zombie.asm:    bp->s.size += p->s.ptr->s.size;
user/zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/zombie.asm:    bp->s.ptr = p->s.ptr;
user/zombie.asm:  if(p + p->s.size == bp){
user/zombie.asm:    p->s.size += bp->s.size;
user/zombie.asm:    p->s.ptr = bp->s.ptr;
user/zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/zombie.asm:  if(bp + bp->s.size == p->s.ptr){
user/zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/zombie.asm:  if(p + p->s.size == bp){
user/zombie.asm:    p->s.ptr = bp->s.ptr;
user/zombie.asm:    p->s.ptr = bp;
user/zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/zombie.asm:    if(p->s.size >= nunits){
user/zombie.asm:        p->s.size = nunits;
user/zombie.asm:    if(p->s.size >= nunits){
user/zombie.asm:      if(p->s.size == nunits)
user/zombie.asm:        p->s.size -= nunits;
user/zombie.asm:        p += p->s.size;
user/zombie.asm:        p->s.size = nunits;
user/zombie.asm:        prevp->s.ptr = p->s.ptr;
user/zombie.asm:  hp->s.size = nu;
user/zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/zombie.asm:    if(p->s.size >= nunits){
user/time1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/time1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/time1.asm:  if(bp + bp->s.size == p->s.ptr){
user/time1.asm:    bp->s.size += p->s.ptr->s.size;
user/time1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/time1.asm:    bp->s.ptr = p->s.ptr;
user/time1.asm:  if(p + p->s.size == bp){
user/time1.asm:    p->s.size += bp->s.size;
user/time1.asm:    p->s.ptr = bp->s.ptr;
user/time1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/time1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/time1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/time1.asm:  if(bp + bp->s.size == p->s.ptr){
user/time1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/time1.asm:  if(p + p->s.size == bp){
user/time1.asm:    p->s.ptr = bp->s.ptr;
user/time1.asm:    p->s.ptr = bp;
user/time1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/time1.asm:    if(p->s.size >= nunits){
user/time1.asm:        p->s.size = nunits;
user/time1.asm:    if(p->s.size >= nunits){
user/time1.asm:      if(p->s.size == nunits)
user/time1.asm:        p->s.size -= nunits;
user/time1.asm:        p += p->s.size;
user/time1.asm:        p->s.size = nunits;
user/time1.asm:        prevp->s.ptr = p->s.ptr;
user/time1.asm:  hp->s.size = nu;
user/time1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/time1.asm:    if(p->s.size >= nunits){
user/sleep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/sleep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/sleep.asm:  if(bp + bp->s.size == p->s.ptr){
user/sleep.asm:    bp->s.size += p->s.ptr->s.size;
user/sleep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/sleep.asm:    bp->s.ptr = p->s.ptr;
user/sleep.asm:  if(p + p->s.size == bp){
user/sleep.asm:    p->s.size += bp->s.size;
user/sleep.asm:    p->s.ptr = bp->s.ptr;
user/sleep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/sleep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/sleep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/sleep.asm:  if(bp + bp->s.size == p->s.ptr){
user/sleep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/sleep.asm:  if(p + p->s.size == bp){
user/sleep.asm:    p->s.ptr = bp->s.ptr;
user/sleep.asm:    p->s.ptr = bp;
user/sleep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/sleep.asm:    if(p->s.size >= nunits){
user/sleep.asm:        p->s.size = nunits;
user/sleep.asm:    if(p->s.size >= nunits){
user/sleep.asm:      if(p->s.size == nunits)
user/sleep.asm:        p->s.size -= nunits;
user/sleep.asm:        p += p->s.size;
user/sleep.asm:        p->s.size = nunits;
user/sleep.asm:        prevp->s.ptr = p->s.ptr;
user/sleep.asm:  hp->s.size = nu;
user/sleep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/sleep.asm:    if(p->s.size >= nunits){
user/echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/echo.asm:  if(bp + bp->s.size == p->s.ptr){
user/echo.asm:    bp->s.size += p->s.ptr->s.size;
user/echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/echo.asm:    bp->s.ptr = p->s.ptr;
user/echo.asm:  if(p + p->s.size == bp){
user/echo.asm:    p->s.size += bp->s.size;
user/echo.asm:    p->s.ptr = bp->s.ptr;
user/echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/echo.asm:  if(bp + bp->s.size == p->s.ptr){
user/echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/echo.asm:  if(p + p->s.size == bp){
user/echo.asm:    p->s.ptr = bp->s.ptr;
user/echo.asm:    p->s.ptr = bp;
user/echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/echo.asm:    if(p->s.size >= nunits){
user/echo.asm:        p->s.size = nunits;
user/echo.asm:    if(p->s.size >= nunits){
user/echo.asm:      if(p->s.size == nunits)
user/echo.asm:        p->s.size -= nunits;
user/echo.asm:        p += p->s.size;
user/echo.asm:        p->s.size = nunits;
user/echo.asm:        prevp->s.ptr = p->s.ptr;
user/echo.asm:  hp->s.size = nu;
user/echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/echo.asm:    if(p->s.size >= nunits){
user/ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ps.asm:  if(bp + bp->s.size == p->s.ptr){
user/ps.asm:    bp->s.size += p->s.ptr->s.size;
user/ps.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/ps.asm:    bp->s.ptr = p->s.ptr;
user/ps.asm:  if(p + p->s.size == bp){
user/ps.asm:    p->s.size += bp->s.size;
user/ps.asm:    p->s.ptr = bp->s.ptr;
user/ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ps.asm:  if(bp + bp->s.size == p->s.ptr){
user/ps.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/ps.asm:  if(p + p->s.size == bp){
user/ps.asm:    p->s.ptr = bp->s.ptr;
user/ps.asm:    p->s.ptr = bp;
user/ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/ps.asm:    if(p->s.size >= nunits){
user/ps.asm:        p->s.size = nunits;
user/ps.asm:    if(p->s.size >= nunits){
user/ps.asm:      if(p->s.size == nunits)
user/ps.asm:        p->s.size -= nunits;
user/ps.asm:        p += p->s.size;
user/ps.asm:        p->s.size = nunits;
user/ps.asm:        prevp->s.ptr = p->s.ptr;
user/ps.asm:  hp->s.size = nu;
user/ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/ps.asm:    if(p->s.size >= nunits){
user/pexec.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/pexec.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pexec.asm:  if(bp + bp->s.size == p->s.ptr){
user/pexec.asm:    bp->s.size += p->s.ptr->s.size;
user/pexec.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/pexec.asm:    bp->s.ptr = p->s.ptr;
user/pexec.asm:  if(p + p->s.size == bp){
user/pexec.asm:    p->s.size += bp->s.size;
user/pexec.asm:    p->s.ptr = bp->s.ptr;
user/pexec.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pexec.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/pexec.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pexec.asm:  if(bp + bp->s.size == p->s.ptr){
user/pexec.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/pexec.asm:  if(p + p->s.size == bp){
user/pexec.asm:    p->s.ptr = bp->s.ptr;
user/pexec.asm:    p->s.ptr = bp;
user/pexec.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/pexec.asm:    if(p->s.size >= nunits){
user/pexec.asm:        p->s.size = nunits;
user/pexec.asm:    if(p->s.size >= nunits){
user/pexec.asm:      if(p->s.size == nunits)
user/pexec.asm:        p->s.size -= nunits;
user/pexec.asm:        p += p->s.size;
user/pexec.asm:        p->s.size = nunits;
user/pexec.asm:        prevp->s.ptr = p->s.ptr;
user/pexec.asm:  hp->s.size = nu;
user/pexec.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/pexec.asm:    if(p->s.size >= nunits){
user/uptime.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/uptime.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/uptime.asm:  if(bp + bp->s.size == p->s.ptr){
user/uptime.asm:    bp->s.size += p->s.ptr->s.size;
user/uptime.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/uptime.asm:    bp->s.ptr = p->s.ptr;
user/uptime.asm:  if(p + p->s.size == bp){
user/uptime.asm:    p->s.size += bp->s.size;
user/uptime.asm:    p->s.ptr = bp->s.ptr;
user/uptime.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/uptime.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/uptime.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/uptime.asm:  if(bp + bp->s.size == p->s.ptr){
user/uptime.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/uptime.asm:  if(p + p->s.size == bp){
user/uptime.asm:    p->s.ptr = bp->s.ptr;
user/uptime.asm:    p->s.ptr = bp;
user/uptime.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/uptime.asm:    if(p->s.size >= nunits){
user/uptime.asm:        p->s.size = nunits;
user/uptime.asm:    if(p->s.size >= nunits){
user/uptime.asm:      if(p->s.size == nunits)
user/uptime.asm:        p->s.size -= nunits;
user/uptime.asm:        p += p->s.size;
user/uptime.asm:        p->s.size = nunits;
user/uptime.asm:        prevp->s.ptr = p->s.ptr;
user/uptime.asm:  hp->s.size = nu;
user/uptime.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/uptime.asm:    if(p->s.size >= nunits){
user/ls.c:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
user/grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/grep.asm:  if(bp + bp->s.size == p->s.ptr){
user/grep.asm:    bp->s.size += p->s.ptr->s.size;
user/grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/grep.asm:    bp->s.ptr = p->s.ptr;
user/grep.asm:  if(p + p->s.size == bp){
user/grep.asm:    p->s.size += bp->s.size;
user/grep.asm:    p->s.ptr = bp->s.ptr;
user/grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/grep.asm:  if(bp + bp->s.size == p->s.ptr){
user/grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/grep.asm:  if(p + p->s.size == bp){
user/grep.asm:    p->s.ptr = bp->s.ptr;
user/grep.asm:    p->s.ptr = bp;
user/grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/grep.asm:    if(p->s.size >= nunits){
user/grep.asm:        p->s.size = nunits;
user/grep.asm:    if(p->s.size >= nunits){
user/grep.asm:      if(p->s.size == nunits)
user/grep.asm:        p->s.size -= nunits;
user/grep.asm:        p += p->s.size;
user/grep.asm:        p->s.size = nunits;
user/grep.asm:        prevp->s.ptr = p->s.ptr;
user/grep.asm:  hp->s.size = nu;
user/grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/grep.asm:    if(p->s.size >= nunits){
user/ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ln.asm:  if(bp + bp->s.size == p->s.ptr){
user/ln.asm:    bp->s.size += p->s.ptr->s.size;
user/ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/ln.asm:    bp->s.ptr = p->s.ptr;
user/ln.asm:  if(p + p->s.size == bp){
user/ln.asm:    p->s.size += bp->s.size;
user/ln.asm:    p->s.ptr = bp->s.ptr;
user/ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ln.asm:  if(bp + bp->s.size == p->s.ptr){
user/ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/ln.asm:  if(p + p->s.size == bp){
user/ln.asm:    p->s.ptr = bp->s.ptr;
user/ln.asm:    p->s.ptr = bp;
user/ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/ln.asm:    if(p->s.size >= nunits){
user/ln.asm:        p->s.size = nunits;
user/ln.asm:    if(p->s.size >= nunits){
user/ln.asm:      if(p->s.size == nunits)
user/ln.asm:        p->s.size -= nunits;
user/ln.asm:        p += p->s.size;
user/ln.asm:        p->s.size = nunits;
user/ln.asm:        prevp->s.ptr = p->s.ptr;
user/ln.asm:  hp->s.size = nu;
user/ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/ln.asm:    if(p->s.size >= nunits){
user/grind.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/grind.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/grind.asm:  if(bp + bp->s.size == p->s.ptr){
user/grind.asm:    bp->s.size += p->s.ptr->s.size;
user/grind.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/grind.asm:    bp->s.ptr = p->s.ptr;
user/grind.asm:  if(p + p->s.size == bp){
user/grind.asm:    p->s.size += bp->s.size;
user/grind.asm:    p->s.ptr = bp->s.ptr;
user/grind.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/grind.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/grind.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/grind.asm:  if(bp + bp->s.size == p->s.ptr){
user/grind.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/grind.asm:  if(p + p->s.size == bp){
user/grind.asm:    p->s.ptr = bp->s.ptr;
user/grind.asm:    p->s.ptr = bp;
user/grind.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/grind.asm:    if(p->s.size >= nunits){
user/grind.asm:        p->s.size = nunits;
user/grind.asm:    if(p->s.size >= nunits){
user/grind.asm:      if(p->s.size == nunits)
user/grind.asm:        p->s.size -= nunits;
user/grind.asm:        p += p->s.size;
user/grind.asm:        p->s.size = nunits;
user/grind.asm:        prevp->s.ptr = p->s.ptr;
user/grind.asm:  hp->s.size = nu;
user/grind.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/grind.asm:    if(p->s.size >= nunits){
user/init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/init.asm:  if(bp + bp->s.size == p->s.ptr){
user/init.asm:    bp->s.size += p->s.ptr->s.size;
user/init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/init.asm:    bp->s.ptr = p->s.ptr;
user/init.asm:  if(p + p->s.size == bp){
user/init.asm:    p->s.size += bp->s.size;
user/init.asm:    p->s.ptr = bp->s.ptr;
user/init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/init.asm:  if(bp + bp->s.size == p->s.ptr){
user/init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/init.asm:  if(p + p->s.size == bp){
user/init.asm:    p->s.ptr = bp->s.ptr;
user/init.asm:    p->s.ptr = bp;
user/init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/init.asm:    if(p->s.size >= nunits){
user/init.asm:        p->s.size = nunits;
user/init.asm:    if(p->s.size >= nunits){
user/init.asm:      if(p->s.size == nunits)
user/init.asm:        p->s.size -= nunits;
user/init.asm:        p += p->s.size;
user/init.asm:        p->s.size = nunits;
user/init.asm:        prevp->s.ptr = p->s.ptr;
user/init.asm:  hp->s.size = nu;
user/init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/init.asm:    if(p->s.size >= nunits){
user/pstest.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/pstest.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pstest.asm:  if(bp + bp->s.size == p->s.ptr){
user/pstest.asm:    bp->s.size += p->s.ptr->s.size;
user/pstest.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/pstest.asm:    bp->s.ptr = p->s.ptr;
user/pstest.asm:  if(p + p->s.size == bp){
user/pstest.asm:    p->s.size += bp->s.size;
user/pstest.asm:    p->s.ptr = bp->s.ptr;
user/pstest.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pstest.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/pstest.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/pstest.asm:  if(bp + bp->s.size == p->s.ptr){
user/pstest.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/pstest.asm:  if(p + p->s.size == bp){
user/pstest.asm:    p->s.ptr = bp->s.ptr;
user/pstest.asm:    p->s.ptr = bp;
user/pstest.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/pstest.asm:    if(p->s.size >= nunits){
user/pstest.asm:        p->s.size = nunits;
user/pstest.asm:    if(p->s.size >= nunits){
user/pstest.asm:      if(p->s.size == nunits)
user/pstest.asm:        p->s.size -= nunits;
user/pstest.asm:        p += p->s.size;
user/pstest.asm:        p->s.size = nunits;
user/pstest.asm:        prevp->s.ptr = p->s.ptr;
user/pstest.asm:  hp->s.size = nu;
user/pstest.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/pstest.asm:    if(p->s.size >= nunits){
user/stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
user/stressfs.asm:    bp->s.size += p->s.ptr->s.size;
user/stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/stressfs.asm:    bp->s.ptr = p->s.ptr;
user/stressfs.asm:  if(p + p->s.size == bp){
user/stressfs.asm:    p->s.size += bp->s.size;
user/stressfs.asm:    p->s.ptr = bp->s.ptr;
user/stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
user/stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/stressfs.asm:  if(p + p->s.size == bp){
user/stressfs.asm:    p->s.ptr = bp->s.ptr;
user/stressfs.asm:    p->s.ptr = bp;
user/stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/stressfs.asm:    if(p->s.size >= nunits){
user/stressfs.asm:        p->s.size = nunits;
user/stressfs.asm:    if(p->s.size >= nunits){
user/stressfs.asm:      if(p->s.size == nunits)
user/stressfs.asm:        p->s.size -= nunits;
user/stressfs.asm:        p += p->s.size;
user/stressfs.asm:        p->s.size = nunits;
user/stressfs.asm:        prevp->s.ptr = p->s.ptr;
user/stressfs.asm:  hp->s.size = nu;
user/stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/stressfs.asm:    if(p->s.size >= nunits){
user/sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/sh.asm:  if(bp + bp->s.size == p->s.ptr){
user/sh.asm:    bp->s.size += p->s.ptr->s.size;
user/sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/sh.asm:    bp->s.ptr = p->s.ptr;
user/sh.asm:  if(p + p->s.size == bp){
user/sh.asm:    p->s.size += bp->s.size;
user/sh.asm:    p->s.ptr = bp->s.ptr;
user/sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/sh.asm:  if(bp + bp->s.size == p->s.ptr){
user/sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/sh.asm:  if(p + p->s.size == bp){
user/sh.asm:    p->s.ptr = bp->s.ptr;
user/sh.asm:    p->s.ptr = bp;
user/sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/sh.asm:    if(p->s.size >= nunits){
user/sh.asm:        p->s.size = nunits;
user/sh.asm:    if(p->s.size >= nunits){
user/sh.asm:      if(p->s.size == nunits)
user/sh.asm:        p->s.size -= nunits;
user/sh.asm:        p += p->s.size;
user/sh.asm:        p->s.size = nunits;
user/sh.asm:        prevp->s.ptr = p->s.ptr;
user/sh.asm:  hp->s.size = nu;
user/sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/sh.asm:    if(p->s.size >= nunits){
user/kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/kill.asm:  if(bp + bp->s.size == p->s.ptr){
user/kill.asm:    bp->s.size += p->s.ptr->s.size;
user/kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/kill.asm:    bp->s.ptr = p->s.ptr;
user/kill.asm:  if(p + p->s.size == bp){
user/kill.asm:    p->s.size += bp->s.size;
user/kill.asm:    p->s.ptr = bp->s.ptr;
user/kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/kill.asm:  if(bp + bp->s.size == p->s.ptr){
user/kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/kill.asm:  if(p + p->s.size == bp){
user/kill.asm:    p->s.ptr = bp->s.ptr;
user/kill.asm:    p->s.ptr = bp;
user/kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/kill.asm:    if(p->s.size >= nunits){
user/kill.asm:        p->s.size = nunits;
user/kill.asm:    if(p->s.size >= nunits){
user/kill.asm:      if(p->s.size == nunits)
user/kill.asm:        p->s.size -= nunits;
user/kill.asm:        p += p->s.size;
user/kill.asm:        p->s.size = nunits;
user/kill.asm:        prevp->s.ptr = p->s.ptr;
user/kill.asm:  hp->s.size = nu;
user/kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/kill.asm:    if(p->s.size >= nunits){
user/usertests.asm:  *(top-1) = *(top-1) + 1;
user/usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/usertests.asm:  if(bp + bp->s.size == p->s.ptr){
user/usertests.asm:    bp->s.size += p->s.ptr->s.size;
user/usertests.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/usertests.asm:    bp->s.ptr = p->s.ptr;
user/usertests.asm:  if(p + p->s.size == bp){
user/usertests.asm:    p->s.size += bp->s.size;
user/usertests.asm:    p->s.ptr = bp->s.ptr;
user/usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/usertests.asm:  if(bp + bp->s.size == p->s.ptr){
user/usertests.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/usertests.asm:  if(p + p->s.size == bp){
user/usertests.asm:    p->s.ptr = bp->s.ptr;
user/usertests.asm:    p->s.ptr = bp;
user/usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/usertests.asm:    if(p->s.size >= nunits){
user/usertests.asm:        p->s.size = nunits;
user/usertests.asm:    if(p->s.size >= nunits){
user/usertests.asm:      if(p->s.size == nunits)
user/usertests.asm:        p->s.size -= nunits;
user/usertests.asm:        p += p->s.size;
user/usertests.asm:        p->s.size = nunits;
user/usertests.asm:        prevp->s.ptr = p->s.ptr;
user/usertests.asm:  hp->s.size = nu;
user/usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/usertests.asm:    if(p->s.size >= nunits){
user/ls.asm:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
user/ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ls.asm:  if(bp + bp->s.size == p->s.ptr){
user/ls.asm:    bp->s.size += p->s.ptr->s.size;
user/ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/ls.asm:    bp->s.ptr = p->s.ptr;
user/ls.asm:  if(p + p->s.size == bp){
user/ls.asm:    p->s.size += bp->s.size;
user/ls.asm:    p->s.ptr = bp->s.ptr;
user/ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/ls.asm:  if(bp + bp->s.size == p->s.ptr){
user/ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/ls.asm:  if(p + p->s.size == bp){
user/ls.asm:    p->s.ptr = bp->s.ptr;
user/ls.asm:    p->s.ptr = bp;
user/ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/ls.asm:    if(p->s.size >= nunits){
user/ls.asm:        p->s.size = nunits;
user/ls.asm:    if(p->s.size >= nunits){
user/ls.asm:      if(p->s.size == nunits)
user/ls.asm:        p->s.size -= nunits;
user/ls.asm:        p += p->s.size;
user/ls.asm:        p->s.size = nunits;
user/ls.asm:        prevp->s.ptr = p->s.ptr;
user/ls.asm:  hp->s.size = nu;
user/ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/ls.asm:    if(p->s.size >= nunits){
user/testpriority.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/testpriority.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/testpriority.asm:  if(bp + bp->s.size == p->s.ptr){
user/testpriority.asm:    bp->s.size += p->s.ptr->s.size;
user/testpriority.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/testpriority.asm:    bp->s.ptr = p->s.ptr;
user/testpriority.asm:  if(p + p->s.size == bp){
user/testpriority.asm:    p->s.size += bp->s.size;
user/testpriority.asm:    p->s.ptr = bp->s.ptr;
user/testpriority.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/testpriority.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/testpriority.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/testpriority.asm:  if(bp + bp->s.size == p->s.ptr){
user/testpriority.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/testpriority.asm:  if(p + p->s.size == bp){
user/testpriority.asm:    p->s.ptr = bp->s.ptr;
user/testpriority.asm:    p->s.ptr = bp;
user/testpriority.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/testpriority.asm:    if(p->s.size >= nunits){
user/testpriority.asm:        p->s.size = nunits;
user/testpriority.asm:    if(p->s.size >= nunits){
user/testpriority.asm:      if(p->s.size == nunits)
user/testpriority.asm:        p->s.size -= nunits;
user/testpriority.asm:        p += p->s.size;
user/testpriority.asm:        p->s.size = nunits;
user/testpriority.asm:        prevp->s.ptr = p->s.ptr;
user/testpriority.asm:  hp->s.size = nu;
user/testpriority.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/testpriority.asm:    if(p->s.size >= nunits){
user/mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
user/mkdir.asm:    bp->s.size += p->s.ptr->s.size;
user/mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/mkdir.asm:    bp->s.ptr = p->s.ptr;
user/mkdir.asm:  if(p + p->s.size == bp){
user/mkdir.asm:    p->s.size += bp->s.size;
user/mkdir.asm:    p->s.ptr = bp->s.ptr;
user/mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
user/mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/mkdir.asm:  if(p + p->s.size == bp){
user/mkdir.asm:    p->s.ptr = bp->s.ptr;
user/mkdir.asm:    p->s.ptr = bp;
user/mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/mkdir.asm:    if(p->s.size >= nunits){
user/mkdir.asm:        p->s.size = nunits;
user/mkdir.asm:    if(p->s.size >= nunits){
user/mkdir.asm:      if(p->s.size == nunits)
user/mkdir.asm:        p->s.size -= nunits;
user/mkdir.asm:        p += p->s.size;
user/mkdir.asm:        p->s.size = nunits;
user/mkdir.asm:        prevp->s.ptr = p->s.ptr;
user/mkdir.asm:  hp->s.size = nu;
user/mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/mkdir.asm:    if(p->s.size >= nunits){
user/time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/time.asm:  if(bp + bp->s.size == p->s.ptr){
user/time.asm:    bp->s.size += p->s.ptr->s.size;
user/time.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/time.asm:    bp->s.ptr = p->s.ptr;
user/time.asm:  if(p + p->s.size == bp){
user/time.asm:    p->s.size += bp->s.size;
user/time.asm:    p->s.ptr = bp->s.ptr;
user/time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/time.asm:  if(bp + bp->s.size == p->s.ptr){
user/time.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/time.asm:  if(p + p->s.size == bp){
user/time.asm:    p->s.ptr = bp->s.ptr;
user/time.asm:    p->s.ptr = bp;
user/time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/time.asm:    if(p->s.size >= nunits){
user/time.asm:        p->s.size = nunits;
user/time.asm:    if(p->s.size >= nunits){
user/time.asm:      if(p->s.size == nunits)
user/time.asm:        p->s.size -= nunits;
user/time.asm:        p += p->s.size;
user/time.asm:        p->s.size = nunits;
user/time.asm:        prevp->s.ptr = p->s.ptr;
user/time.asm:  hp->s.size = nu;
user/time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/time.asm:    if(p->s.size >= nunits){
user/cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/cat.asm:  if(bp + bp->s.size == p->s.ptr){
user/cat.asm:    bp->s.size += p->s.ptr->s.size;
user/cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/cat.asm:    bp->s.ptr = p->s.ptr;
user/cat.asm:  if(p + p->s.size == bp){
user/cat.asm:    p->s.size += bp->s.size;
user/cat.asm:    p->s.ptr = bp->s.ptr;
user/cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/cat.asm:  if(bp + bp->s.size == p->s.ptr){
user/cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/cat.asm:  if(p + p->s.size == bp){
user/cat.asm:    p->s.ptr = bp->s.ptr;
user/cat.asm:    p->s.ptr = bp;
user/cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/cat.asm:    if(p->s.size >= nunits){
user/cat.asm:        p->s.size = nunits;
user/cat.asm:    if(p->s.size >= nunits){
user/cat.asm:      if(p->s.size == nunits)
user/cat.asm:        p->s.size -= nunits;
user/cat.asm:        p += p->s.size;
user/cat.asm:        p->s.size = nunits;
user/cat.asm:        prevp->s.ptr = p->s.ptr;
user/cat.asm:  hp->s.size = nu;
user/cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/cat.asm:    if(p->s.size >= nunits){
user/free.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/free.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/free.asm:  if(bp + bp->s.size == p->s.ptr){
user/free.asm:    bp->s.size += p->s.ptr->s.size;
user/free.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/free.asm:    bp->s.ptr = p->s.ptr;
user/free.asm:  if(p + p->s.size == bp){
user/free.asm:    p->s.size += bp->s.size;
user/free.asm:    p->s.ptr = bp->s.ptr;
user/free.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/free.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/free.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/free.asm:  if(bp + bp->s.size == p->s.ptr){
user/free.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/free.asm:  if(p + p->s.size == bp){
user/free.asm:    p->s.ptr = bp->s.ptr;
user/free.asm:    p->s.ptr = bp;
user/free.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/free.asm:    if(p->s.size >= nunits){
user/free.asm:        p->s.size = nunits;
user/free.asm:    if(p->s.size >= nunits){
user/free.asm:      if(p->s.size == nunits)
user/free.asm:        p->s.size -= nunits;
user/free.asm:        p += p->s.size;
user/free.asm:        p->s.size = nunits;
user/free.asm:        prevp->s.ptr = p->s.ptr;
user/free.asm:  hp->s.size = nu;
user/free.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/free.asm:    if(p->s.size >= nunits){
user/rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/rm.asm:  if(bp + bp->s.size == p->s.ptr){
user/rm.asm:    bp->s.size += p->s.ptr->s.size;
user/rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/rm.asm:    bp->s.ptr = p->s.ptr;
user/rm.asm:  if(p + p->s.size == bp){
user/rm.asm:    p->s.size += bp->s.size;
user/rm.asm:    p->s.ptr = bp->s.ptr;
user/rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/rm.asm:  if(bp + bp->s.size == p->s.ptr){
user/rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/rm.asm:  if(p + p->s.size == bp){
user/rm.asm:    p->s.ptr = bp->s.ptr;
user/rm.asm:    p->s.ptr = bp;
user/rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/rm.asm:    if(p->s.size >= nunits){
user/rm.asm:        p->s.size = nunits;
user/rm.asm:    if(p->s.size >= nunits){
user/rm.asm:      if(p->s.size == nunits)
user/rm.asm:        p->s.size -= nunits;
user/rm.asm:        p += p->s.size;
user/rm.asm:        p->s.size = nunits;
user/rm.asm:        prevp->s.ptr = p->s.ptr;
user/rm.asm:  hp->s.size = nu;
user/rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/rm.asm:    if(p->s.size >= nunits){
user/matmul.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/matmul.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/matmul.asm:  if(bp + bp->s.size == p->s.ptr){
user/matmul.asm:    bp->s.size += p->s.ptr->s.size;
user/matmul.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/matmul.asm:    bp->s.ptr = p->s.ptr;
user/matmul.asm:  if(p + p->s.size == bp){
user/matmul.asm:    p->s.size += bp->s.size;
user/matmul.asm:    p->s.ptr = bp->s.ptr;
user/matmul.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/matmul.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/matmul.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/matmul.asm:  if(bp + bp->s.size == p->s.ptr){
user/matmul.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/matmul.asm:  if(p + p->s.size == bp){
user/matmul.asm:    p->s.ptr = bp->s.ptr;
user/matmul.asm:    p->s.ptr = bp;
user/matmul.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/matmul.asm:    if(p->s.size >= nunits){
user/matmul.asm:        p->s.size = nunits;
user/matmul.asm:    if(p->s.size >= nunits){
user/matmul.asm:      if(p->s.size == nunits)
user/matmul.asm:        p->s.size -= nunits;
user/matmul.asm:        p += p->s.size;
user/matmul.asm:        p->s.size = nunits;
user/matmul.asm:        prevp->s.ptr = p->s.ptr;
user/matmul.asm:  hp->s.size = nu;
user/matmul.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/matmul.asm:    if(p->s.size >= nunits){
user/wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/wc.asm:  if(bp + bp->s.size == p->s.ptr){
user/wc.asm:    bp->s.size += p->s.ptr->s.size;
user/wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/wc.asm:    bp->s.ptr = p->s.ptr;
user/wc.asm:  if(p + p->s.size == bp){
user/wc.asm:    p->s.size += bp->s.size;
user/wc.asm:    p->s.ptr = bp->s.ptr;
user/wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
user/wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
user/wc.asm:  if(bp + bp->s.size == p->s.ptr){
user/wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
user/wc.asm:  if(p + p->s.size == bp){
user/wc.asm:    p->s.ptr = bp->s.ptr;
user/wc.asm:    p->s.ptr = bp;
user/wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/wc.asm:    if(p->s.size >= nunits){
user/wc.asm:        p->s.size = nunits;
user/wc.asm:    if(p->s.size >= nunits){
user/wc.asm:      if(p->s.size == nunits)
user/wc.asm:        p->s.size -= nunits;
user/wc.asm:        p += p->s.size;
user/wc.asm:        p->s.size = nunits;
user/wc.asm:        prevp->s.ptr = p->s.ptr;
user/wc.asm:  hp->s.size = nu;
user/wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
user/wc.asm:    if(p->s.size >= nunits){
.git/hooks/push-to-checkout.sample:	die "Up-to-date check failed"
kernel/file.c:    if(copyout(p->pagetable, addr, (char *)&st, sizeof(st)) < 0)
kernel/sysfile.c:    if(p->ofile[fd] == 0){
kernel/sysfile.c:      p->ofile[fd] = f;
kernel/sysfile.c:  if(ip->type == T_DIR){
kernel/sysfile.c:  ip->nlink++;
kernel/sysfile.c:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
kernel/sysfile.c:  ip->nlink--;
kernel/sysfile.c:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel/sysfile.c:  if(ip->nlink < 1)
kernel/sysfile.c:  if(ip->type == T_DIR && !isdirempty(ip)){
kernel/sysfile.c:  if(ip->type == T_DIR){
kernel/sysfile.c:    dp->nlink--;
kernel/sysfile.c:  ip->nlink--;
kernel/sysfile.c:    if(type == T_FILE && (ip->type == T_FILE || ip->type == T_DEVICE))
kernel/sysfile.c:  if((ip = ialloc(dp->dev, type)) == 0)
kernel/sysfile.c:  ip->major = major;
kernel/sysfile.c:  ip->minor = minor;
kernel/sysfile.c:  ip->nlink = 1;
kernel/sysfile.c:    dp->nlink++;  // for ".."
kernel/sysfile.c:    // No ip->nlink++ for ".": avoid cyclic ref count.
kernel/sysfile.c:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
kernel/sysfile.c:  if(dirlink(dp, name, ip->inum) < 0)
kernel/sysfile.c:    if(ip->type == T_DIR && omode != O_RDONLY){
kernel/sysfile.c:  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
kernel/sysfile.c:  if(ip->type == T_DEVICE){
kernel/sysfile.c:    f->major = ip->major;
kernel/sysfile.c:  if((omode & O_TRUNC) && ip->type == T_FILE){
kernel/sysfile.c:  if(ip->type != T_DIR){
kernel/sysfile.c:  iput(p->cwd);
kernel/sysfile.c:  p->cwd = ip;
kernel/sysfile.c:      p->ofile[fd0] = 0;
kernel/sysfile.c:  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
kernel/sysfile.c:     copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
kernel/sysfile.c:    p->ofile[fd0] = 0;
kernel/sysfile.c:    p->ofile[fd1] = 0;
kernel/sysfile.c:// Search p->mmr[] for unused location 
kernel/sysfile.c:    if (p->mmr[i].valid == 0) {
kernel/sysfile.c:      newmmr = &(p->mmr[i]);
kernel/sysfile.c:    start_addr = PGROUNDDOWN(p->cur_max - length) & ~(PGSIZE - 1);  //hw5.1
kernel/sysfile.c:    newmmr->length = p->cur_max - start_addr;
kernel/sysfile.c:  if (mapvpages(p->pagetable, newmmr->addr, newmmr->length) < 0) {
kernel/sysfile.c:  p->cur_max = start_addr;
kernel/sysfile.c:    if ((p->mmr[i].valid == 1) && (addr == p->mmr[i].addr) &&
kernel/sysfile.c:      (PGROUNDUP(length) == p->mmr[i].length)) {
kernel/sysfile.c:      mmr = &(p->mmr[i]);
kernel/sysfile.c:  for (uint64 pageaddr = addr; pageaddr < p->mmr[i].addr+p->mmr[i].length; pageaddr += PGSIZE) {
kernel/sysfile.c:    if (walkaddr(p->pagetable, pageaddr)) {
kernel/sysfile.c:      uvmunmap(p->pagetable, pageaddr, 1, dofree);
kernel/vm.c:  if(va >= p->sz || va < PGROUNDUP(p->trapframe->sp)){
kernel/vm.c:    if(mappages(p->pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){
kernel/fs.c:  memmove(sb, bp->data, sizeof(*sb));
kernel/fs.c:  memset(bp->data, 0, BSIZE);
kernel/fs.c:      if((bp->data[bi/8] & m) == 0){  // Is block free?
kernel/fs.c:        bp->data[bi/8] |= m;  // Mark block in use.
kernel/fs.c:  if((bp->data[bi/8] & m) == 0)
kernel/fs.c:  bp->data[bi/8] &= ~m;
kernel/fs.c:// not stored on disk: ip->ref and ip->valid.
kernel/fs.c://   is free if ip->ref is zero. Otherwise ip->ref tracks
kernel/fs.c://   table entry is only correct when ip->valid is 1.
kernel/fs.c://   the disk and sets ip->valid, while iput() clears
kernel/fs.c://   ip->valid if ip->ref has fallen to zero.
kernel/fs.c://   ... examine and modify ip->xxx ...
kernel/fs.c:// pathname lookup. iget() increments ip->ref so that the inode
kernel/fs.c:// entries. Since ip->ref indicates whether an entry is free,
kernel/fs.c:// and ip->dev and ip->inum indicate which i-node an entry
kernel/fs.c:// An ip->lock sleep-lock protects all ip-> fields other than ref,
kernel/fs.c:// dev, and inum.  One must hold ip->lock in order to
kernel/fs.c:// read or write that inode's ip->valid, ip->size, ip->type, &c.
kernel/fs.c:    dip = (struct dinode*)bp->data + inum%IPB;
kernel/fs.c:    if(dip->type == 0){  // a free inode
kernel/fs.c:      dip->type = type;
kernel/fs.c:// Must be called after every change to an ip->xxx field
kernel/fs.c:// Caller must hold ip->lock.
kernel/fs.c:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/fs.c:  dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/fs.c:  dip->type = ip->type;
kernel/fs.c:  dip->major = ip->major;
kernel/fs.c:  dip->minor = ip->minor;
kernel/fs.c:  dip->nlink = ip->nlink;
kernel/fs.c:  dip->size = ip->size;
kernel/fs.c:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
kernel/fs.c:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
kernel/fs.c:      ip->ref++;
kernel/fs.c:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel/fs.c:  ip->dev = dev;
kernel/fs.c:  ip->inum = inum;
kernel/fs.c:  ip->ref = 1;
kernel/fs.c:  ip->valid = 0;
kernel/fs.c:  ip->ref++;
kernel/fs.c:  if(ip == 0 || ip->ref < 1)
kernel/fs.c:  acquiresleep(&ip->lock);
kernel/fs.c:  if(ip->valid == 0){
kernel/fs.c:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/fs.c:    dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/fs.c:    ip->type = dip->type;
kernel/fs.c:    ip->major = dip->major;
kernel/fs.c:    ip->minor = dip->minor;
kernel/fs.c:    ip->nlink = dip->nlink;
kernel/fs.c:    ip->size = dip->size;
kernel/fs.c:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
kernel/fs.c:    ip->valid = 1;
kernel/fs.c:    if(ip->type == 0)
kernel/fs.c:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
kernel/fs.c:  releasesleep(&ip->lock);
kernel/fs.c:  if(ip->ref == 1 && ip->valid && ip->nlink == 0){
kernel/fs.c:    // ip->ref == 1 means no other process can have ip locked,
kernel/fs.c:    acquiresleep(&ip->lock);
kernel/fs.c:    ip->type = 0;
kernel/fs.c:    ip->valid = 0;
kernel/fs.c:    releasesleep(&ip->lock);
kernel/fs.c:  ip->ref--;
kernel/fs.c:// are listed in ip->addrs[].  The next NINDIRECT blocks are
kernel/fs.c:// listed in block ip->addrs[NDIRECT].
kernel/fs.c:    if((addr = ip->addrs[bn]) == 0)
kernel/fs.c:      ip->addrs[bn] = addr = balloc(ip->dev);
kernel/fs.c:    if((addr = ip->addrs[NDIRECT]) == 0)
kernel/fs.c:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
kernel/fs.c:    bp = bread(ip->dev, addr);
kernel/fs.c:    a = (uint*)bp->data;
kernel/fs.c:      a[bn] = addr = balloc(ip->dev);
kernel/fs.c:// Caller must hold ip->lock.
kernel/fs.c:    if(ip->addrs[i]){
kernel/fs.c:      bfree(ip->dev, ip->addrs[i]);
kernel/fs.c:      ip->addrs[i] = 0;
kernel/fs.c:  if(ip->addrs[NDIRECT]){
kernel/fs.c:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel/fs.c:    a = (uint*)bp->data;
kernel/fs.c:        bfree(ip->dev, a[j]);
kernel/fs.c:    bfree(ip->dev, ip->addrs[NDIRECT]);
kernel/fs.c:    ip->addrs[NDIRECT] = 0;
kernel/fs.c:  ip->size = 0;
kernel/fs.c:// Caller must hold ip->lock.
kernel/fs.c:  st->dev = ip->dev;
kernel/fs.c:  st->ino = ip->inum;
kernel/fs.c:  st->type = ip->type;
kernel/fs.c:  st->nlink = ip->nlink;
kernel/fs.c:  st->size = ip->size;
kernel/fs.c:// Caller must hold ip->lock.
kernel/fs.c:  if(off > ip->size || off + n < off)
kernel/fs.c:  if(off + n > ip->size)
kernel/fs.c:    n = ip->size - off;
kernel/fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/fs.c:    if(either_copyout(user_dst, dst, bp->data + (off % BSIZE), m) == -1) {
kernel/fs.c:// Caller must hold ip->lock.
kernel/fs.c:  if(off > ip->size || off + n < off)
kernel/fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/fs.c:    if(either_copyin(bp->data + (off % BSIZE), user_src, src, m) == -1) {
kernel/fs.c:  if(off > ip->size)
kernel/fs.c:    ip->size = off;
kernel/fs.c:  // block to ip->addrs[].
kernel/fs.c:  if(dp->type != T_DIR)
kernel/fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/fs.c:      return iget(dp->dev, inum);
kernel/fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/fs.c:    if(ip->type != T_DIR){
kernel/trap.c:  p->trapframe->epc = r_sepc();
kernel/trap.c:    if(p->killed)
kernel/trap.c:    p->trapframe->epc += 4;
kernel/trap.c:	/*if (faulting_address >= p->sz){
kernel/trap.c:	  p->killed = 1;
kernel/trap.c:      //printf("p size: %p\n", p->sz);
kernel/trap.c:      printf("In trap.c \n_____Faulting address: %p\n_____p size %p\n", faulting_address, p->sz);
kernel/trap.c:      if(faulting_address >= p->sz){
kernel/trap.c:   	   if (p->mmr[i].valid != 1 &&
kernel/trap.c:             addr < p->mmr[i].addr &&
kernel/trap.c:             addr >= p->mmr[i].addr + p->mmr[i].length &&
kernel/trap.c:             addr + length > p->mmr[i].addr + p->mmr[i].length) {
kernel/trap.c:             mmr = &(p->mmr[i]);
kernel/trap.c:             p->killed = 1;
kernel/trap.c:      //if(faulting_address < p->sz){
kernel/trap.c:          p->killed = 1;
kernel/trap.c:        if(mappages(p->pagetable, pg_round_down, PGSIZE, (uint64)memory, PTE_W | PTE_X |PTE_R |PTE_U)      
kernel/trap.c:          printf("___p size: %p\n", p->sz);
kernel/trap.c:          p->killed = 1;
kernel/trap.c:          printf("___p size after: %p\n", p->sz);
kernel/trap.c:          //p->killed = 1;
kernel/trap.c:      p->cputime++;
kernel/trap.c:  if(p->killed)
kernel/trap.c:  p->trapframe->kernel_satp = r_satp();         // kernel page table
kernel/trap.c:  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
kernel/trap.c:  p->trapframe->kernel_trap = (uint64)usertrap;
kernel/trap.c:  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
kernel/trap.c:  w_sepc(p->trapframe->epc);
kernel/trap.c:  uint64 satp = MAKE_SATP(p->pagetable);
kernel/riscv.h:// Supervisor Trap-Vector Base Address
kernel/proc.h:  // p->lock must be held when using these:
kernel/proc.h:  // these are private to the process, so p->lock need not be held.
kernel/exec.c:  uint64 oldsz = p->sz;
kernel/exec.c:  p->trapframe->a1 = sp;
kernel/exec.c:  safestrcpy(p->name, last, sizeof(p->name));
kernel/exec.c:  oldpagetable = p->pagetable;
kernel/exec.c:  p->pagetable = pagetable;
kernel/exec.c:  p->sz = sz;
kernel/exec.c:  p->trapframe->epc = elf.entry;  // initial program counter = main
kernel/exec.c:  p->trapframe->sp = sp; // initial stack pointer
kernel/uart.c:// called from both the top- and bottom-half.
kernel/syscall.c:  if(addr >= p->sz || addr+sizeof(uint64) > p->sz)
kernel/syscall.c:  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
kernel/syscall.c:  int err = copyinstr(p->pagetable, buf, addr, max);
kernel/syscall.c:    return p->trapframe->a0;
kernel/syscall.c:    return p->trapframe->a1;
kernel/syscall.c:    return p->trapframe->a2;
kernel/syscall.c:    return p->trapframe->a3;
kernel/syscall.c:    return p->trapframe->a4;
kernel/syscall.c:    return p->trapframe->a5;
kernel/syscall.c:  num = p->trapframe->a7;
kernel/syscall.c:    p->trapframe->a0 = syscalls[num]();
kernel/syscall.c:            p->pid, p->name, num);
kernel/syscall.c:    p->trapframe->a0 = -1;
kernel/proc.c:// memory model when using p->parent.
kernel/proc.c:// must be acquired before any p->lock.
kernel/proc.c:      initlock(&p->lock, "proc");
kernel/proc.c:      p->kstack = KSTACK((int) (p - proc));
kernel/proc.c:// and return with p->lock held.
kernel/proc.c:    acquire(&p->lock);
kernel/proc.c:    if(p->state == UNUSED) {
kernel/proc.c:      release(&p->lock);
kernel/proc.c:  p->pid = allocpid();
kernel/proc.c:  p->state = USED;
kernel/proc.c:  p->cputime = 0;    
kernel/proc.c:  p->priority =0;                           // user added cputime
kernel/proc.c:  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
kernel/proc.c:    release(&p->lock);
kernel/proc.c:  p->pagetable = proc_pagetable(p);
kernel/proc.c:  if(p->pagetable == 0){
kernel/proc.c:    release(&p->lock);
kernel/proc.c:  memset(&p->context, 0, sizeof(p->context));
kernel/proc.c:  p->context.ra = (uint64)forkret;
kernel/proc.c:  p->context.sp = p->kstack + PGSIZE;
kernel/proc.c:// p->lock must be held.
kernel/proc.c:  if(p->trapframe)
kernel/proc.c:    kfree((void*)p->trapframe);
kernel/proc.c:  p->trapframe = 0;
kernel/proc.c:  if(p->pagetable)
kernel/proc.c:    proc_freepagetable(p->pagetable, p->sz);
kernel/proc.c:  p->pagetable = 0;
kernel/proc.c:  p->sz = 0;
kernel/proc.c:  p->pid = 0;
kernel/proc.c:  p->parent = 0;
kernel/proc.c:  p->name[0] = 0;
kernel/proc.c:  p->chan = 0;
kernel/proc.c:  p->killed = 0;
kernel/proc.c:  p->xstate = 0;
kernel/proc.c:  p->state = UNUSED;
kernel/proc.c:              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
kernel/proc.c:  uvminit(p->pagetable, initcode, sizeof(initcode));
kernel/proc.c:  p->sz = PGSIZE;
kernel/proc.c:  p->trapframe->epc = 0;      // user program counter
kernel/proc.c:  p->trapframe->sp = PGSIZE;  // user stack pointer
kernel/proc.c:  p->cur_max = MAXVA - 2 * PGSIZE;  //hw5.1a
kernel/proc.c:  printf("__________In proc.c: p->cur_max  is %p\n", p->cur_max);
kernel/proc.c:  safestrcpy(p->name, "initcode", sizeof(p->name));
kernel/proc.c:  p->cwd = namei("/");
kernel/proc.c:  p->state = RUNNABLE;
kernel/proc.c:  if (p->state == RUNNABLE) {
kernel/proc.c:    p->readytime = p->cputime;
kernel/proc.c:  //p->priority = uptime();
kernel/proc.c:  release(&p->lock);
kernel/proc.c:  sz = p->sz;
kernel/proc.c:    if((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
kernel/proc.c:    sz = uvmdealloc(p->pagetable, sz, sz + n);
kernel/proc.c:  p->sz = sz;
kernel/proc.c:  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
kernel/proc.c:    release(&np->lock);
kernel/proc.c:  np->sz = p->sz;
kernel/proc.c:  np->cur_max = p->cur_max;
kernel/proc.c:  *(np->trapframe) = *(p->trapframe);
kernel/proc.c:  np->trapframe->a0 = 0;
kernel/proc.c:    if(p->ofile[i])
kernel/proc.c:      np->ofile[i] = filedup(p->ofile[i]);
kernel/proc.c:  np->cwd = idup(p->cwd);
kernel/proc.c:  safestrcpy(np->name, p->name, sizeof(p->name));
kernel/proc.c:  pid = np->pid;
kernel/proc.c:  release(&np->lock);
kernel/proc.c:  np->parent = p;
kernel/proc.c:  acquire(&np->lock);
kernel/proc.c:  np->state = RUNNABLE;
kernel/proc.c:   if (p->state == RUNNABLE) {
kernel/proc.c:    p->readytime = p->cputime;
kernel/proc.c:  release(&np->lock);
kernel/proc.c:    if(pp->parent == p){
kernel/proc.c:      pp->parent = initproc;
kernel/proc.c:    if(p->ofile[fd]){
kernel/proc.c:      struct file *f = p->ofile[fd];
kernel/proc.c:      p->ofile[fd] = 0;
kernel/proc.c:  iput(p->cwd);
kernel/proc.c:  p->cwd = 0;
kernel/proc.c:  wakeup(p->parent);
kernel/proc.c:  acquire(&p->lock);
kernel/proc.c:  p->xstate = status;
kernel/proc.c:  p->state = ZOMBIE;
kernel/proc.c:      if(np->parent == p){
kernel/proc.c:        acquire(&np->lock);
kernel/proc.c:        if(np->state == ZOMBIE){
kernel/proc.c:          pid = np->pid;
kernel/proc.c:          if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
kernel/proc.c:                                  sizeof(np->xstate)) < 0) {
kernel/proc.c:            release(&np->lock);
kernel/proc.c:          release(&np->lock);
kernel/proc.c:        release(&np->lock);
kernel/proc.c:    if(!havekids || p->killed){
kernel/proc.c:      if(np->parent == p){
kernel/proc.c:        acquire(&np->lock);
kernel/proc.c:        if(np->state == ZOMBIE){
kernel/proc.c:          pid = np->pid;
kernel/proc.c:          if(addr1 != 0 && copyout(p->pagetable, addr1, (char *)&np->xstate,
kernel/proc.c:                                  sizeof(np->xstate)) < 0) {
kernel/proc.c:            release(&np->lock);
kernel/proc.c:          rusage.cputime = np->cputime;
kernel/proc.c:          if(addr2 != 0 && copyout(p->pagetable, addr2, (char *)&rusage,
kernel/proc.c:            release(&np->lock);
kernel/proc.c:          release(&np->lock);
kernel/proc.c:        release(&np->lock);
kernel/proc.c:    if(!havekids || p->killed){
kernel/proc.c:      acquire(&p->lock);
kernel/proc.c:      if(p->state == RUNNABLE) {
kernel/proc.c:        p->readytime = p->cputime;
kernel/proc.c:        int effective_priority = min(MAXEFFPRIORITY, p->priority  + (p->cputime - p->readytime));
kernel/proc.c:        p->effectPriority =effective_priority;
kernel/proc.c:        //release(&p->lock);
kernel/proc.c:        p->state = RUNNING;
kernel/proc.c:        swtch(&c->context, &p->context);
kernel/proc.c:        // It should have changed its p->state before coming back.
kernel/proc.c:       // release(&p->lock);
kernel/proc.c:      release(&p->lock);
kernel/proc.c:// Switch to scheduler.  Must hold only p->lock
kernel/proc.c:  if(!holding(&p->lock))
kernel/proc.c:    panic("sched p->lock");
kernel/proc.c:  if(p->state == RUNNING)
kernel/proc.c:  swtch(&p->context, &mycpu()->context);
kernel/proc.c:  acquire(&p->lock);
kernel/proc.c:  p->state = RUNNABLE;
kernel/proc.c:   if (p->state == RUNNABLE) {
kernel/proc.c:    p->readytime = p->cputime;
kernel/proc.c:  release(&p->lock);
kernel/proc.c:  // Still holding p->lock from scheduler.
kernel/proc.c:  // Must acquire p->lock in order to
kernel/proc.c:  // change p->state and then call sched.
kernel/proc.c:  // Once we hold p->lock, we can be
kernel/proc.c:  // (wakeup locks p->lock),
kernel/proc.c:  acquire(&p->lock);  //DOC: sleeplock1
kernel/proc.c:  p->chan = chan;
kernel/proc.c:  p->state = SLEEPING;
kernel/proc.c:  p->chan = 0;
kernel/proc.c:  release(&p->lock);
kernel/proc.c:// Must be called without any p->lock.
kernel/proc.c:      acquire(&p->lock);
kernel/proc.c:      if(p->state == SLEEPING && p->chan == chan) {
kernel/proc.c:        p->state = RUNNABLE;
kernel/proc.c:         if (p->state == RUNNABLE) {
kernel/proc.c:            p->readytime = p->cputime;
kernel/proc.c:      release(&p->lock);
kernel/proc.c:    acquire(&p->lock);
kernel/proc.c:    if(p->pid == pid){
kernel/proc.c:      p->killed = 1;
kernel/proc.c:      if(p->state == SLEEPING){
kernel/proc.c:        p->state = RUNNABLE;
kernel/proc.c:         if (p->state == RUNNABLE) {
kernel/proc.c:              p->readytime = p->cputime;
kernel/proc.c:      release(&p->lock);
kernel/proc.c:    release(&p->lock);
kernel/proc.c:    return copyout(p->pagetable, dst, src, len);
kernel/proc.c:    return copyin(p->pagetable, dst, src, len);
kernel/proc.c:    if(p->state == UNUSED)
kernel/proc.c:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
kernel/proc.c:      state = states[p->state];
kernel/proc.c:    printf("%d %s %s", p->pid, state, p->name);
kernel/proc.c:    if(p->state == UNUSED)
kernel/proc.c:    procinfo.pid = p->pid;
kernel/proc.c:    procinfo.state = p->state;
kernel/proc.c:    procinfo.size = p->sz;
kernel/proc.c:    procinfo.priority = p->priority;
kernel/proc.c:    procinfo.cputime = p->cputime;
kernel/proc.c:    if (p->parent)
kernel/proc.c:      procinfo.ppid = (p->parent)->pid;
kernel/proc.c:      procinfo.name[i] = p->name[i];
kernel/memlayout.h://   TRAPFRAME (p->trapframe, used by the trampoline)
kernel/trampoline.S:        # sscratch points to where the process's p->trapframe is
kernel/trampoline.S:	# save the user a0 in p->trapframe->a0
kernel/trampoline.S:        # restore kernel stack pointer from p->trapframe->kernel_sp
kernel/trampoline.S:        # make tp hold the current hartid, from p->trapframe->kernel_hartid
kernel/trampoline.S:        # load the address of usertrap(), p->trapframe->kernel_trap
kernel/trampoline.S:        # restore kernel page table from p->trapframe->kernel_satp
kernel/trampoline.S:        # table does not specially map p->tf.
kernel/log.c://   modify bp->data[]
kernel/kernel.asm:// called from both the top- and bottom-half.
kernel/kernel.asm:  if(va >= p->sz || va < PGROUNDUP(p->trapframe->sp)){
kernel/kernel.asm:  if(va >= p->sz || va < PGROUNDUP(p->trapframe->sp)){
kernel/kernel.asm:  if(va >= p->sz || va < PGROUNDUP(p->trapframe->sp)){
kernel/kernel.asm:    if(mappages(p->pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){
kernel/kernel.asm:      initlock(&p->lock, "proc");
kernel/kernel.asm:      p->kstack = KSTACK((int) (p - proc));
kernel/kernel.asm:      initlock(&p->lock, "proc");
kernel/kernel.asm:      p->kstack = KSTACK((int) (p - proc));
kernel/kernel.asm:  // Still holding p->lock from scheduler.
kernel/kernel.asm:  if(p->trapframe)
kernel/kernel.asm:    kfree((void*)p->trapframe);
kernel/kernel.asm:  p->trapframe = 0;
kernel/kernel.asm:  if(p->pagetable)
kernel/kernel.asm:    proc_freepagetable(p->pagetable, p->sz);
kernel/kernel.asm:  p->pagetable = 0;
kernel/kernel.asm:  p->sz = 0;
kernel/kernel.asm:  p->pid = 0;
kernel/kernel.asm:  p->parent = 0;
kernel/kernel.asm:  p->name[0] = 0;
kernel/kernel.asm:  p->chan = 0;
kernel/kernel.asm:  p->killed = 0;
kernel/kernel.asm:  p->xstate = 0;
kernel/kernel.asm:  p->state = UNUSED;
kernel/kernel.asm:    acquire(&p->lock);
kernel/kernel.asm:    if(p->state == UNUSED) {
kernel/kernel.asm:      release(&p->lock);
kernel/kernel.asm:  p->pid = allocpid();
kernel/kernel.asm:  p->state = USED;
kernel/kernel.asm:  p->cputime = 0;    
kernel/kernel.asm:  p->priority =0;                           // user added cputime
kernel/kernel.asm:  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
kernel/kernel.asm:  p->pagetable = proc_pagetable(p);
kernel/kernel.asm:  if(p->pagetable == 0){
kernel/kernel.asm:  memset(&p->context, 0, sizeof(p->context));
kernel/kernel.asm:  p->context.ra = (uint64)forkret;
kernel/kernel.asm:  p->context.sp = p->kstack + PGSIZE;
kernel/kernel.asm:    release(&p->lock);
kernel/kernel.asm:    release(&p->lock);
kernel/kernel.asm:  uvminit(p->pagetable, initcode, sizeof(initcode));
kernel/kernel.asm:  p->sz = PGSIZE;
kernel/kernel.asm:  p->trapframe->epc = 0;      // user program counter
kernel/kernel.asm:  p->trapframe->sp = PGSIZE;  // user stack pointer
kernel/kernel.asm:  p->cur_max = MAXVA - 2 * PGSIZE;  //hw5.1a
kernel/kernel.asm:  printf("__________In proc.c: p->cur_max  is %p\n", p->cur_max);
kernel/kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
kernel/kernel.asm:  p->cwd = namei("/");
kernel/kernel.asm:  p->state = RUNNABLE;
kernel/kernel.asm:    p->readytime = p->cputime;
kernel/kernel.asm:  release(&p->lock);
kernel/kernel.asm:  sz = p->sz;
kernel/kernel.asm:  p->sz = sz;
kernel/kernel.asm:    if((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
kernel/kernel.asm:    sz = uvmdealloc(p->pagetable, sz, sz + n);
kernel/kernel.asm:  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
kernel/kernel.asm:  np->sz = p->sz;
kernel/kernel.asm:  np->cur_max = p->cur_max;
kernel/kernel.asm:  *(np->trapframe) = *(p->trapframe);
kernel/kernel.asm:  np->trapframe->a0 = 0;
kernel/kernel.asm:    release(&np->lock);
kernel/kernel.asm:    if(p->ofile[i])
kernel/kernel.asm:      np->ofile[i] = filedup(p->ofile[i]);
kernel/kernel.asm:  np->cwd = idup(p->cwd);
kernel/kernel.asm:  safestrcpy(np->name, p->name, sizeof(p->name));
kernel/kernel.asm:  pid = np->pid;
kernel/kernel.asm:  release(&np->lock);
kernel/kernel.asm:  np->parent = p;
kernel/kernel.asm:  acquire(&np->lock);
kernel/kernel.asm:  np->state = RUNNABLE;
kernel/kernel.asm:   if (p->state == RUNNABLE) {
kernel/kernel.asm:  release(&np->lock);
kernel/kernel.asm:    p->readytime = p->cputime;
kernel/kernel.asm:        swtch(&c->context, &p->context);
kernel/kernel.asm:      if(p->state == RUNNABLE) {
kernel/kernel.asm:        p->state = RUNNING;
kernel/kernel.asm:        swtch(&c->context, &p->context);
kernel/kernel.asm:      release(&p->lock);
kernel/kernel.asm:      acquire(&p->lock);
kernel/kernel.asm:      if(p->state == RUNNABLE) {
kernel/kernel.asm:        p->readytime = p->cputime;
kernel/kernel.asm:        p->effectPriority =effective_priority;
kernel/kernel.asm:  if(!holding(&p->lock))
kernel/kernel.asm:  if(p->state == RUNNING)
kernel/kernel.asm:  swtch(&p->context, &mycpu()->context);
kernel/kernel.asm:    panic("sched p->lock");
kernel/kernel.asm:  acquire(&p->lock);
kernel/kernel.asm:  p->state = RUNNABLE;
kernel/kernel.asm:    p->readytime = p->cputime;
kernel/kernel.asm:  release(&p->lock);
kernel/kernel.asm:  // Once we hold p->lock, we can be
kernel/kernel.asm:  // (wakeup locks p->lock),
kernel/kernel.asm:  acquire(&p->lock);  //DOC: sleeplock1
kernel/kernel.asm:  p->chan = chan;
kernel/kernel.asm:  p->state = SLEEPING;
kernel/kernel.asm:  p->chan = 0;
kernel/kernel.asm:  release(&p->lock);
kernel/kernel.asm:        if(np->state == ZOMBIE){
kernel/kernel.asm:          pid = np->pid;
kernel/kernel.asm:          if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
kernel/kernel.asm:          release(&np->lock);
kernel/kernel.asm:            release(&np->lock);
kernel/kernel.asm:      if(np->parent == p){
kernel/kernel.asm:        acquire(&np->lock);
kernel/kernel.asm:        if(np->state == ZOMBIE){
kernel/kernel.asm:        release(&np->lock);
kernel/kernel.asm:    if(!havekids || p->killed){
kernel/kernel.asm:        if(np->state == ZOMBIE){
kernel/kernel.asm:          pid = np->pid;
kernel/kernel.asm:          if(addr1 != 0 && copyout(p->pagetable, addr1, (char *)&np->xstate,
kernel/kernel.asm:          rusage.cputime = np->cputime;
kernel/kernel.asm:          if(addr2 != 0 && copyout(p->pagetable, addr2, (char *)&rusage,
kernel/kernel.asm:          release(&np->lock);
kernel/kernel.asm:          if(addr1 != 0 && copyout(p->pagetable, addr1, (char *)&np->xstate,
kernel/kernel.asm:            release(&np->lock);
kernel/kernel.asm:            release(&np->lock);
kernel/kernel.asm:      if(np->parent == p){
kernel/kernel.asm:        acquire(&np->lock);
kernel/kernel.asm:        if(np->state == ZOMBIE){
kernel/kernel.asm:        release(&np->lock);
kernel/kernel.asm:    if(!havekids || p->killed){
kernel/kernel.asm:// Must be called without any p->lock.
kernel/kernel.asm:      acquire(&p->lock);
kernel/kernel.asm:      if(p->state == SLEEPING && p->chan == chan) {
kernel/kernel.asm:        p->state = RUNNABLE;
kernel/kernel.asm:            p->readytime = p->cputime;
kernel/kernel.asm:      release(&p->lock);
kernel/kernel.asm:      acquire(&p->lock);
kernel/kernel.asm:      if(p->state == SLEEPING && p->chan == chan) {
kernel/kernel.asm:        p->state = RUNNABLE;
kernel/kernel.asm:            p->readytime = p->cputime;
kernel/kernel.asm:      pp->parent = initproc;
kernel/kernel.asm:    if(pp->parent == p){
kernel/kernel.asm:      pp->parent = initproc;
kernel/kernel.asm:      p->ofile[fd] = 0;
kernel/kernel.asm:    if(p->ofile[fd]){
kernel/kernel.asm:  iput(p->cwd);
kernel/kernel.asm:  p->cwd = 0;
kernel/kernel.asm:  wakeup(p->parent);
kernel/kernel.asm:  acquire(&p->lock);
kernel/kernel.asm:  p->xstate = status;
kernel/kernel.asm:  p->state = ZOMBIE;
kernel/kernel.asm:    acquire(&p->lock);
kernel/kernel.asm:    if(p->pid == pid){
kernel/kernel.asm:      release(&p->lock);
kernel/kernel.asm:    release(&p->lock);
kernel/kernel.asm:      p->killed = 1;
kernel/kernel.asm:      if(p->state == SLEEPING){
kernel/kernel.asm:      release(&p->lock);
kernel/kernel.asm:        p->state = RUNNABLE;
kernel/kernel.asm:              p->readytime = p->cputime;
kernel/kernel.asm:    return copyout(p->pagetable, dst, src, len);
kernel/kernel.asm:    return copyin(p->pagetable, dst, src, len);
kernel/kernel.asm:    if(p->state == UNUSED)
kernel/kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
kernel/kernel.asm:      state = states[p->state];
kernel/kernel.asm:    printf("%d %s %s", p->pid, state, p->name);
kernel/kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
kernel/kernel.asm:    printf("%d %s %s", p->pid, state, p->name);
kernel/kernel.asm:    if(p->state == UNUSED)
kernel/kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
kernel/kernel.asm:    procinfo.cputime = p->cputime;
kernel/kernel.asm:    if (p->parent)
kernel/kernel.asm:      procinfo.ppid = (p->parent)->pid;
kernel/kernel.asm:      procinfo.name[i] = p->name[i];
kernel/kernel.asm:    if(p->state == UNUSED)
kernel/kernel.asm:    procinfo.pid = p->pid;
kernel/kernel.asm:    procinfo.state = p->state;
kernel/kernel.asm:    procinfo.size = p->sz;
kernel/kernel.asm:    procinfo.priority = p->priority;
kernel/kernel.asm:    procinfo.cputime = p->cputime;
kernel/kernel.asm:    if (p->parent)
kernel/kernel.asm:    if (p->parent)
kernel/kernel.asm:      procinfo.ppid = (p->parent)->pid;
kernel/kernel.asm:  p->trapframe->kernel_satp = r_satp();         // kernel page table
kernel/kernel.asm:  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
kernel/kernel.asm:  p->trapframe->kernel_trap = (uint64)usertrap;
kernel/kernel.asm:  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
kernel/kernel.asm:  w_sepc(p->trapframe->epc);
kernel/kernel.asm:  uint64 satp = MAKE_SATP(p->pagetable);
kernel/kernel.asm:  p->trapframe->epc = r_sepc();
kernel/kernel.asm:    if(p->killed)
kernel/kernel.asm:    p->trapframe->epc += 4;
kernel/kernel.asm:  if(p->killed)
kernel/kernel.asm:      printf("In trap.c \n_____Faulting address: %p\n_____p size %p\n", faulting_address, p->sz);
kernel/kernel.asm:      if(faulting_address < p->sz){
kernel/kernel.asm:        if(mappages(p->pagetable, pg_round_down, PGSIZE, (uint64)memory, PTE_W | PTE_X |PTE_R |PTE_U)      
kernel/kernel.asm:          printf("___p size: %p\n", p->sz);
kernel/kernel.asm:          p->killed = 1;
kernel/kernel.asm:          p->killed = 1;
kernel/kernel.asm:          printf("___p size after: %p\n", p->sz);
kernel/kernel.asm:      p->cputime++;
kernel/kernel.asm:    return p->trapframe->a0;
kernel/kernel.asm:    return p->trapframe->a5;
kernel/kernel.asm:    return p->trapframe->a1;
kernel/kernel.asm:    return p->trapframe->a2;
kernel/kernel.asm:    return p->trapframe->a3;
kernel/kernel.asm:    return p->trapframe->a4;
kernel/kernel.asm:    return p->trapframe->a5;
kernel/kernel.asm:  if(addr >= p->sz || addr+sizeof(uint64) > p->sz)
kernel/kernel.asm:  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
kernel/kernel.asm:  int err = copyinstr(p->pagetable, buf, addr, max);
kernel/kernel.asm:  num = p->trapframe->a7;
kernel/kernel.asm:    p->trapframe->a0 = syscalls[num]();
kernel/kernel.asm:            p->pid, p->name, num);
kernel/kernel.asm:    p->trapframe->a0 = -1;
kernel/kernel.asm:  if((bp->data[bi/8] & m) == 0)
kernel/kernel.asm:  bp->data[bi/8] &= ~m;
kernel/kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
kernel/kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
kernel/kernel.asm:  memset(bp->data, 0, BSIZE);
kernel/kernel.asm:    if((addr = ip->addrs[bn]) == 0)
kernel/kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
kernel/kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
kernel/kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
kernel/kernel.asm:    bp = bread(ip->dev, addr);
kernel/kernel.asm:    a = (uint*)bp->data;
kernel/kernel.asm:      a[bn] = addr = balloc(ip->dev);
kernel/kernel.asm:    if((addr = ip->addrs[bn]) == 0)
kernel/kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
kernel/kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
kernel/kernel.asm:      a[bn] = addr = balloc(ip->dev);
kernel/kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel/kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
kernel/kernel.asm:      ip->ref++;
kernel/kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel/kernel.asm:  ip->dev = dev;
kernel/kernel.asm:  ip->inum = inum;
kernel/kernel.asm:  ip->ref = 1;
kernel/kernel.asm:  ip->valid = 0;
kernel/kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
kernel/kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
kernel/kernel.asm:    if(dip->type == 0){  // a free inode
kernel/kernel.asm:      dip->type = type;
kernel/kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/kernel.asm:  dip->type = ip->type;
kernel/kernel.asm:  dip->major = ip->major;
kernel/kernel.asm:  dip->minor = ip->minor;
kernel/kernel.asm:  dip->nlink = ip->nlink;
kernel/kernel.asm:  dip->size = ip->size;
kernel/kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
kernel/kernel.asm:  ip->ref++;
kernel/kernel.asm:  if(ip == 0 || ip->ref < 1)
kernel/kernel.asm:  acquiresleep(&ip->lock);
kernel/kernel.asm:  if(ip->valid == 0){
kernel/kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/kernel.asm:    ip->type = dip->type;
kernel/kernel.asm:    ip->major = dip->major;
kernel/kernel.asm:    ip->minor = dip->minor;
kernel/kernel.asm:    ip->nlink = dip->nlink;
kernel/kernel.asm:    ip->size = dip->size;
kernel/kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
kernel/kernel.asm:    ip->valid = 1;
kernel/kernel.asm:    if(ip->type == 0)
kernel/kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
kernel/kernel.asm:  releasesleep(&ip->lock);
kernel/kernel.asm:// Caller must hold ip->lock.
kernel/kernel.asm:    if(ip->addrs[i]){
kernel/kernel.asm:      bfree(ip->dev, ip->addrs[i]);
kernel/kernel.asm:      ip->addrs[i] = 0;
kernel/kernel.asm:  if(ip->addrs[NDIRECT]){
kernel/kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
kernel/kernel.asm:    ip->addrs[NDIRECT] = 0;
kernel/kernel.asm:  ip->size = 0;
kernel/kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel/kernel.asm:        bfree(ip->dev, a[j]);
kernel/kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
kernel/kernel.asm:    ip->addrs[NDIRECT] = 0;
kernel/kernel.asm:  if(ip->ref == 1 && ip->valid && ip->nlink == 0){
kernel/kernel.asm:  ip->ref--;
kernel/kernel.asm:  if(ip->ref == 1 && ip->valid && ip->nlink == 0){
kernel/kernel.asm:    acquiresleep(&ip->lock);
kernel/kernel.asm:    ip->type = 0;
kernel/kernel.asm:    ip->valid = 0;
kernel/kernel.asm:    releasesleep(&ip->lock);
kernel/kernel.asm:// Caller must hold ip->lock.
kernel/kernel.asm:  st->dev = ip->dev;
kernel/kernel.asm:  st->ino = ip->inum;
kernel/kernel.asm:  st->type = ip->type;
kernel/kernel.asm:  st->nlink = ip->nlink;
kernel/kernel.asm:  st->size = ip->size;
kernel/kernel.asm:  if(off > ip->size || off + n < off)
kernel/kernel.asm:  if(off > ip->size || off + n < off)
kernel/kernel.asm:  if(off > ip->size || off + n < off)
kernel/kernel.asm:  if(off + n > ip->size)
kernel/kernel.asm:    n = ip->size - off;
kernel/kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/kernel.asm:    if(either_copyout(user_dst, dst, bp->data + (off % BSIZE), m) == -1) {
kernel/kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/kernel.asm:  if(off > ip->size || off + n < off)
kernel/kernel.asm:  if(off > ip->size || off + n < off)
kernel/kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/kernel.asm:    if(either_copyin(bp->data + (off % BSIZE), user_src, src, m) == -1) {
kernel/kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/kernel.asm:  if(off > ip->size)
kernel/kernel.asm:    ip->size = off;
kernel/kernel.asm:  // block to ip->addrs[].
kernel/kernel.asm:  if(dp->type != T_DIR)
kernel/kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/kernel.asm:      return iget(dp->dev, inum);
kernel/kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/kernel.asm:      return iget(dp->dev, inum);
kernel/kernel.asm:    if(ip->type != T_DIR){
kernel/kernel.asm:    if(ip->type != T_DIR){
kernel/kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/kernel.asm://   modify bp->data[]
kernel/kernel.asm:    if(copyout(p->pagetable, addr, (char *)&st, sizeof(st)) < 0)
kernel/kernel.asm:  uint64 oldsz = p->sz;
kernel/kernel.asm:  p->trapframe->a1 = sp;
kernel/kernel.asm:  safestrcpy(p->name, last, sizeof(p->name));
kernel/kernel.asm:  oldpagetable = p->pagetable;
kernel/kernel.asm:  p->pagetable = pagetable;
kernel/kernel.asm:  p->sz = sz;
kernel/kernel.asm:  p->trapframe->epc = elf.entry;  // initial program counter = main
kernel/kernel.asm:  p->trapframe->sp = sp; // initial stack pointer
kernel/kernel.asm:    if(p->ofile[fd] == 0){
kernel/kernel.asm:      p->ofile[fd] = f;
kernel/kernel.asm:      p->ofile[fd] = f;
kernel/kernel.asm:    if(type == T_FILE && (ip->type == T_FILE || ip->type == T_DEVICE))
kernel/kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
kernel/kernel.asm:  ip->major = major;
kernel/kernel.asm:  ip->minor = minor;
kernel/kernel.asm:  ip->nlink = 1;
kernel/kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
kernel/kernel.asm:    dp->nlink++;  // for ".."
kernel/kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
kernel/kernel.asm:  if(ip->type == T_DIR){
kernel/kernel.asm:  ip->nlink++;
kernel/kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
kernel/kernel.asm:  ip->nlink--;
kernel/kernel.asm:  if(ip->nlink < 1)
kernel/kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
kernel/kernel.asm:  if(ip->type == T_DIR){
kernel/kernel.asm:  ip->nlink--;
kernel/kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel/kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel/kernel.asm:    dp->nlink--;
kernel/kernel.asm:  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
kernel/kernel.asm:  if(ip->type == T_DEVICE){
kernel/kernel.asm:    f->major = ip->major;
kernel/kernel.asm:  if((omode & O_TRUNC) && ip->type == T_FILE){
kernel/kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
kernel/kernel.asm:    f->major = ip->major;
kernel/kernel.asm:  if(ip->type != T_DIR){
kernel/kernel.asm:  iput(p->cwd);
kernel/kernel.asm:  p->cwd = ip;
kernel/kernel.asm:      p->ofile[fd0] = 0;
kernel/kernel.asm:  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
kernel/kernel.asm:     copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
kernel/kernel.asm:    p->ofile[fd1] = 0;
kernel/kernel.asm:  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
kernel/kernel.asm:    p->ofile[fd0] = 0;
kernel/kernel.asm:    p->ofile[fd1] = 0;
kernel/kernel.asm:      p->ofile[fd0] = 0;
kernel/kernel.asm:// Search p->mmr[] for unused location 
kernel/kernel.asm:    if (p->mmr[i].valid == 0) {
kernel/kernel.asm:  p->cur_max = start_addr;
kernel/kernel.asm:    start_addr = PGROUNDDOWN(p->cur_max - length) & ~(PGSIZE - 1);  //hw5.1
kernel/kernel.asm:    newmmr->length = p->cur_max - start_addr;
kernel/kernel.asm:  if (mapvpages(p->pagetable, newmmr->addr, newmmr->length) < 0) {
kernel/kernel.asm:  p->cur_max = start_addr;
kernel/kernel.asm:    if ((p->mmr[i].valid == 1) && (addr == p->mmr[i].addr) &&
kernel/kernel.asm:      (PGROUNDUP(length) == p->mmr[i].length)) {
kernel/kernel.asm:    if ((p->mmr[i].valid == 1) && (addr == p->mmr[i].addr) &&
kernel/kernel.asm:      (PGROUNDUP(length) == p->mmr[i].length)) {
kernel/kernel.asm:    if ((p->mmr[i].valid == 1) && (addr == p->mmr[i].addr) &&
kernel/kernel.asm:  for (uint64 pageaddr = addr; pageaddr < p->mmr[i].addr+p->mmr[i].length; pageaddr += PGSIZE) {
kernel/kernel.asm:  for (uint64 pageaddr = addr; pageaddr < p->mmr[i].addr+p->mmr[i].length; pageaddr += PGSIZE) {
kernel/kernel.asm:    if (walkaddr(p->pagetable, pageaddr)) {
kernel/kernel.asm:      uvmunmap(p->pagetable, pageaddr, 1, dofree);
